!!!!    4    0    1 1191575749   0000                                         
!   AGILENT ICT STANDARD TESTMAIN       Revision: "Agilent i3070 08.20p WN"
!   STANDARD VERSION
!##############################################################################
!   This "main" program sequences execution of testplan subroutines and
!   assumes that the current working directory is already set to the
!   appropriate board directory.
!   This testmain has included the code to support the following optional
!   features:
!        Data Logging for PushButton QSTATS, QSTATS-II and ART
!        Chek-Point (pin tests)
!        Boundary Scan: Interconnect Plus & ScanWorks
!        Agilent Intelligent Yield Enhancement Test (IYET)
!        Agilent Worst Probe Report (WPR)
!        Agilent First Pass Yield (FPY)
!   Once the testplan is working, you may selectively enable
!   any combination of the features by changing the 'flag' variables
!   in the subroutine "Set_Custom_Options".  Use the following command:
!         find  "!   Other"&" parameters"  ! takes you to option settings
!
!   Turn learn on and run the testplan on a known good board.  After the
!   learning run is successfully completed, the testplan is ready for
!   customization, debug and production testing.
!   Analog limits are logged by standard testmain if and only if the
!   learn flag is on.  Limits must be logged once each time they change
!   in order for PushButton Q-STATS or Q-STATS II to produce histograms.
!
!   If flash is to be programmed on this board, the testplan needs to have the
!   locations marked !flash! modified or reviewed.  Please review the flash
!   manual for full explanation. Key elements include:
!
!   full disabling of buses and upstream control lines is required for safety
!   use ID check for digital test subroutine to ensure proper part placement
!   Cycle power if required to three-state upstream devices

! Miscellaneous string variable size declarations:
dim InvOn$[28], InvOff$[11], O$[128], Retry_Pintest$[168]
dim Cycle_Vacuum$[128], Recycle_Vacuum$[128]
dim Testmain_Revision$[70]
dim Batch$[12], Oper$[25], Testplan$[14], Testrev$[4]
dim Board$[14], Board_Rev$[14], Known_Good$[1]
dim Proc_Step$[5], Log_Path$[80]
! The following is used in the power-supply setup routine for parallel
! power supplies.  It holds masks for comparison.
dim Psgroup(1:16)
option bit 32     ! Prevents range error when comparing Psgroup with MSB set
! IYET
dim IYET_Failing_Tests$(0:2047)[40]
dim IYET_Retest_Failing_Devices$(0:8191)[40]
dim IYET_Top_Retests$(0:8191,2)[40]

!       INITIALIZE BREAK AND ERROR TRAPPING

on break recover Break_Trap
on error recover Error_Trap

!       INITIALIZE VARIABLES

call Initializations

!       SET UP FAILURE ACKNOWLEDGMENT
acknowledge all failures

!       MAIN LOOP FOR REPEATEDLY TESTING A BOARD
!          (executed only once if "learning")

Wait_For_Start:

Pass_Fail_Reported = False
Logging_Started = False
Tests_On_This_Board = 0

if Serializing then
! print using "@"
  if TestEvents then
     rcall GetSerialNumber(Serial$); service "TestEventsUCI"
     if Serial$ = "Cancelled" then goto Abort
  else
     Serial$ = fn Get_Serial_Num$(Serial_Prompt$)
  end if
  Known_Good$ = "n"
  if Serial$ = Known_Good_Board$ then Known_Good$ = "y"
  if Using_AwareTest = True then
    ! remove special characters
    Serial_New$ = fn Remove_Special_Characters$(Serial$)
    Path$ = Serial_Number_Directory$ & Serial_New$ & Serial_Suffix$
    enter Path$,, Err

    !! Added the following code to check for all uppercase or all lowercase
    !! serial numbers.
    if Err then
       Path$ = Serial_Number_Directory$ & upc$(Serial_New$) & Serial_Suffix$
       enter Path$,, Err
       if Err then
          Path$ = Serial_Number_Directory$ & lwc$(Serial_New$) & Serial_Suffix$
          enter Path$,, Err
       end if
    end if

    if Err then
      ! serial number file was not found -- board was not tested on AXI
      if AXI_Tested_Override = False then
        print Not_AXI_Tested$
        goto Wait_For_Start
      else
        ! Add custom code here if serial number is missing and
        ! you do not want to completely skip the PC board test
      end if
    end if
  end if
end if
print | print Place_Board_Prompt$
wait for start
if Using_Multiple_Versions and Version_Prompting = Per_Board then
  call Get_Version_Label
  if nrun = 1 or Version_Inits_Needed then
    call Do_Version_Inits
  end if
end if

!       RE-TEST AFTER PIN-TEST FAILURE

ChekPoint_Retry:

print using "@,/"
print "Name:     ";Board$
print "Revision: ";Board_Rev$
if Serializing then print But$; Serial$
Tests_On_This_Board = Tests_On_This_Board + 1
if Tests_On_This_Board > 1 then print Rep_Test$

!       START LOGGING FOR THIS BOARD

report is Report_Printer$
if Logging then call Start_Logging
Logging_Started = True   ! Also used as reporting flag

!       ACTIVATE VACUUM IN PREPARATION FOR TEST

if Tests_On_This_Board = 1 then faon 1.5
! Warning: Reducing the value for 'faon' from the default value of 1.5
! can potentially cause testhead damage.


!       CHECK FIXTURE CONTACT, THEN
!       LEARN OR TEST (OR RE-TEST) BOARD

unpowered
if (not learning) and Chek_Point_Mode = Pretest then
  if not fn Chek_Point_OK then goto Cleanup
end if
call Test_Sections
if Fpsfailed then goto Error_Trap

!       IF ANY BOARD FAILED TEST, TRY TO FIX IT BY RUNNING PIN TEST

Cleanup:

if boardfailed and Status <> Failed_In_Preshorts then
  if Tests_On_This_Board = 1 and Chek_Point_Mode = Failures then
    unpowered
    if fn Chek_Point_OK then goto ChekPoint_Retry
  end if
end if

!       REMOVE BOARD FROM TESTHEAD AND GENERATE PASS/FAIL MESSAGE
!       THEN TERMINATE LOGGING (IF ENABLED) AND REPORTING

faoff
Pass_Fail_Reported = True

Eject_Ticket: image 13/

if boardfailed then
  if TestEvents then call TestEvent("F") ! Failed.
  if not Using_BtBasic then first pass yield 0, 1 !FPY not Passed and Tested
  print "     **  ";Fail_Msg$;"  **"
  copy Fail_File$ over "/dev/tty"
  if Status = Failed_Pin_Test then
    print " ** ";Pin_Msg$;" **"
  end if
  if learning then Status = Failed_In_Learn
  if Serializing then report Serial_Nr$ & Serial$
  report using Eject_Ticket
  if Using_Buffered_Reporting then report out
else
  if TestEvents then call TestEvent("P") ! Passed
  if not Using_BtBasic then first pass yield 1, 1 !FPY Passed and Tested
  print "     **  ";Pass_Msg$;"  **"
  copy Pass_File$ over "/dev/tty"
  if Using_AwareTest = True then
    enter Path$,, Err  ! check to see if serial number file exists
                       ! Err = 100009 (File Not Found)
    if not Err then    ! Do not create new serial number files
      enter "date +%Y%m%d%H%M |"; Passed_Datetime$
      assign @SNF,Err to Path$; write, append
      if Err then      ! problems writing to serial number file
        print SNF_Error_Msg$  |   print "    ";errm$
        beep
        ! print | print Stop_Msg$
        ! stop
      else
        output @SNF; "passedICT = " & Passed_Datetime$
        assign @SNF to *
      end if
    end if
  end if
end if
report is *
if Logging then
  log board end Status
  log out Log_Path$ & datetime$ & System$ & th$
  log clear
end if
report clear

clear failures
Logging_Started = False

!       END PROGRAM IF LEARNING. OTHERWISE RETURN TO MAIN LOOP

if learning then
   learn off
   print | print Learning_Off_Msg$ | print Stop_Msg$
   if TestEvents then rexit "TestEventsUCI"
   beep
   stop
end if
goto Wait_For_Start

!       END OF MAIN LOOP
!       INTERRUPT HANDLING
! This is the normal entry for Break/Stop detection

Break_Trap:

if TestEvents then call TestEvent("A") ! Aborted
off break
off error
print "     ";Break_Msg$
unpowered,Err
if Err then print errmlong$
if Logging and Logging_Started then
  log board end Break_Code
  log out Log_Path$ & datetime$ & System$ & th$
  log clear
end if
faoff, Err
if Err then print errmlong$
goto Abort

! This is the normal entry for errors occurring in Basic statements

Error_Trap:
off error
print errmlong$
beep
SaveErrn = errn
unpowered,Err
if Err then print errmlong$

!       IF A BOARD IS PRESENT, FAIL IT
!       THEN TERMINATE LOGGING (IF ENABLED) AND REPORTING

if Logging_Started and not Pass_Fail_Reported then
  fail device
  report Board_Not_Tested$
  print "     **  ";Fail_Msg$;"  **"
  copy Fail_File$ over "/dev/tty"
  if Status = Failed_Pin_Test then
    print " ** ";Pin_Msg$;" **"
  end if
  if Serializing then report Serial_Nr$ & Serial$
  report using Eject_Ticket
  if Using_Buffered_Reporting then report out, Err
  report is *, Err
  report clear
end if
if Logging_Started and Logging then
  log using """{@RPT~80|"",80a,""}""" ; errm$(SaveErrn)
  log board end Error_Code, SaveErrn
  log out Log_Path$ & datetime$ & System$ & th$
  log clear
end if

!       REMOVE THE BOARD FROM THE TESTHEAD

faoff, Err
if Err then print errmlong$
if learning or Err then goto Abort
on error recover Error_Trap
goto Wait_For_Start

!       ABORT PROGRAM: UNRECOVERABLE ERROR, LEARN ERROR OR STOP KEY

Abort:

off break
off error
probe report off
report is *, Err
log is *, Err

call Disconnect_FXT_Power_Supplies

beep
if (nrun=1) and not Did_First_Run_Inits then
  print No_Init_Warning$
  clear nrun
else
  if Version_Inits_Needed then
    print No_Version_Init_Warning$
    clear nrun
  end if
end if
print "     ";Stop_Msg$
if TestEvents then rexit "TestEventsUCI"
beep
stop
end

!       END OF ERROR TRAPS

!       Test/Learn Sections
!    [ Assumes unpowered mode. ]
! Note concerning LEARN MODE:  some sections are not truly "learned" but are
! run in learn mode for other reasons.  For example, analog tests may be run
! in learn mode in order to log limits information used by Pushbutton QSTATS,
! and preshorts/shorts are run "just in case" -- to avoid bad learns & damage.
! To keep a section from being run in learn mode, place 'if not learning then'
! just before that section and place 'end if' just after it.
!##############################################################################
sub Test_Sections
global PreshortsMsg$, ShortsMsg$, PowerMsg$, DigitalMsg$, AnalogMsg$
global DigitalFuncMsg$, AnalogPoweredMsg$, BScanIncktMsg$, BScanIntconMsg$
global Status, Failed_In_Preshorts, Failed_In_Shorts, Failed_In_Functional
global Failed_In_Digital, Failed_In_Power_Supplies, Failed_In_Analog
global Logging, True, False, Passed
global Mode$, Failed_In_BScan
global VectorlessTestMsg$, Failed_In_VectorlessTest
global PolarityMsg$, Failed_In_Polarity_Check
global BScanPShortsMsg$
global ConnectCheckMsg$, Failed_In_ConnectCheck
global VerifyGroundsMsg$, Failed_In_Verify_Grounds
global Failed_In_Flash, FlashProgMsg$, Programming
global AnalogClusterMsg$, Failed_In_Analog_Cluster
global BScanSiNailsMsg$, Failed_In_BScan_SiNails
global CoverExtendMsg$, Failed_In_Cover_Extend
global SW_ScanPathVerifyMsg$, Failed_In_SW_Testing
global SW_DrVerifyMsg$, SW_IrVerifyMsg$
global SW_InterconnectMsg$, SW_MemInterconnectMsg$
global SW_ClusterMsg$, SW_MemBistMsg$
global SW_ProgrammingMsg$, Failed_In_SW_Programming
global SW_FlashMsg$, Failed_In_SW_Flash
global PrePoweredMsg$, Failed_In_Pre_Powered
! IYET
global Using_IYET, Sampling, IYET_Preshorts_Attempts, IYET_Shorts_Attempts
global IYET_Analog_Tests_Attempts, IYET_VectorlessTest_Attempts
global IYET_Max_Msg$
global Fpsfailed, TestEvents

! Uncomment the next two lines to setup Fixture Power Supplies
! call Setup_FXT_Power_Supplies (Failed_In_FXT_Power_Supplies, FixturePowerMsg$)
! if Fpsfailed then subexit

if (not Using_IYET) or (Using_IYET and IYET_Preshorts_Attempts = 0) then
   call Pre_Shorts (Failed_In_Preshorts, Mode$ & PreshortsMsg$)
else
   if IYET_Preshorts_Attempts > 0 then
       call IYET (PreshortsMsg$, IYET_Preshorts_Attempts)
   else
       print PreshortsMsg$, IYET_Max_Msg$
       if TestEvents then
          call TestEvent("A") ! Aborted
          rexit "TestEventsUCI"
       end if
       beep
       stop
   end if
end if
! if boardfailed then subexit

if (not Using_IYET) or (Using_IYET and IYET_Shorts_Attempts = 0) then
   call Shorts (Failed_In_Shorts, Mode$ & ShortsMsg$)
else
   if IYET_Shorts_Attempts > 0 then
       call IYET (ShortsMsg$, IYET_Shorts_Attempts)
   else
       print ShortsMsg$, IYET_Max_Msg$
       if TestEvents then
          call TestEvent("A") ! Aborted
          rexit "TestEventsUCI"
       end if
       beep
       stop
   end if
end if
if boardfailed then subexit ! Abort if Continuities/Shorts fails

if Logging or not learning then
   if Using_IYET and not learning and not Sampling then
       if IYET_Analog_Tests_Attempts > 0 then
           call IYET (AnalogMsg$, IYET_Analog_Tests_Attempts)
       end if
       if IYET_Analog_Tests_Attempts = 0 then
           call Analog_Tests (Failed_In_Analog, Mode$ & AnalogMsg$)
       end if
       if IYET_Analog_Tests_Attempts < 0 then
           print AnalogMsg$, IYET_Max_Msg$
           if TestEvents then
              call TestEvent("A") ! Aborted
              rexit "TestEventsUCI"
           end if
           beep
           stop
       end if
   else
       call Analog_Tests (Failed_In_Analog, Mode$ & AnalogMsg$)
   end if
   ! if boardfailed then subexit
end if

if (not Using_IYET) or (Using_IYET and IYET_VectorlessTest_Attempts = 0) then
   call VectorlessTest (Failed_In_VectorlessTest, Mode$ & VectorlessTestMsg$)
else
   if IYET_VectorlessTest_Attempts > 0 then
       call IYET (VectorlessTestMsg$, IYET_VectorlessTest_Attempts)
   else
       print VectorlessTestMsg$, IYET_Max_Msg$
       if TestEvents then
          call TestEvent("A") ! Aborted
          rexit "TestEventsUCI"
       end if
       beep
       stop
   end if
end if
! if boardfailed then subexit

call Polarity_Check (Failed_In_Polarity_Check, Mode$ & PolarityMsg$)
! if boardfailed then subexit

call Connect_Check (Failed_In_ConnectCheck, Mode$ & ConnectCheckMsg$)
! if boardfailed then subexit

call Analog_Cluster_Tests (Failed_In_Analog_Cluster, Mode$ & AnalogClusterMsg$)
if boardfailed then subexit ! Abort if any unpowered tests fail

! The subroutine, "Verify_Grounds" must be run prior to the "powered" command.
! If the board fails, then DO NOT execute the "powered" command.
call Verify_Grounds (Failed_In_Verify_Grounds, Mode$ & VerifyGroundsMsg$)
if boardfailed then subexit

! Uncomment the next line to turn off Fixture Power Supplies
! call Disconnect_FXT_Power_Supplies

prepowered

call Analog_Prepowered_Tests (Failed_In_Pre_Powered, Mode$ & PrePoweredMsg$)
if boardfailed then subexit

powered

! Uncomment the next two lines to setup Fixture Power Supplies
! call Setup_FXT_Power_Supplies (Failed_In_FXT_Power_Supplies, FixturePowerMsg$)
! if Fpsfailed then subexit

! Uncomment the next two lines to setup the Fixture Power Supplies that power the CET card.
! call Setup_CET_FXT_Power_Supplies (Failed_In_CET_FXT_Power_Supplies, CET_FixturePowerMsg$)
! if Fpsfailed then subexit

call Setup_Power_Supplies (Failed_In_Power_Supplies, PowerMsg$)
if boardfailed then
  call Disconnect_Power_On_Board
  subexit
end if


call ScanWorks_Scan_Path_Verify_Tests (Failed_In_SW_Testing, Mode$ & SW_ScanPathVerifyMsg$)
! if boardfailed then
!   call Disconnect_Power_On_Board
!   subexit
! end if

call ScanWorks_Pretest
! if boardfailed then
!   call Disconnect_Power_On_Board
!   subexit
! end if

call BScan_Powered_Shorts_Tests (Failed_In_Shorts, Mode$ & BScanPShortsMsg$)
if boardfailed then ! Abort if any powered shorts tests fail
  call Disconnect_Power_On_Board
  subexit
end if

call BScan_Interconnect_Tests (Failed_In_BScan, Mode$ & BScanIntconMsg$)
! if boardfailed then
!   call Disconnect_Power_On_Board
!   subexit
! end if

!If you:
!       * use both ScanWorks and ICT InterconnectPlus chain tests
! AND   * comment out any ICT interconnect tests (e.g. duplicate coverage)
! AND   * those commented tests have unnailed nodes (possible undetected shorts)
!THEN   * Move the following BScan_Incircuit_Tests routine below the ScanWorks
!               Interconnect_Tests call

! Reason: an interconnect test, which finds shorts, should be run on each chain
! prior to the BScan_Incircuit_Tests routine. The connect tests give precise
! opens diagnostics, but board damage from undetected shorts could occur while
! they are being run.

call BScan_Incircuit_Tests (Failed_In_BScan, Mode$ & BScanIncktMsg$)
! if boardfailed then
!   call Disconnect_Power_On_Board
!   subexit
! end if

call ScanWorks_Interconnect_Tests (Failed_In_SW_Testing, Mode$ & SW_InterconnectMsg$)
! if boardfailed then
!   call Disconnect_Power_On_Board
!   subexit
! end if

call BScan_Silicon_Nails_Tests (Failed_In_BScan_SiNails, Mode$ & BScanSiNailsMsg$)
! if boardfailed then
!   call Disconnect_Power_On_Board
!   subexit
! end if

call Cover_Extend_Tests (Failed_In_Cover_Extend, Mode$ & CoverExtendMsg$)
! if boardfailed then
!   call Disconnect_Power_On_Board
!   subexit
! end if

! If you are using Boundary-Scan and you want to cycle power,
! then uncomment the following call and the if-then-else statements.
! call Reset_Board
! if boardfailed then
!   call Disconnect_Power_On_Board
!   subexit
! end if

call Digital_Tests (Failed_In_Digital, Mode$ & DigitalMsg$)
! if boardfailed then
!   call Disconnect_Power_On_Board
!   subexit
! end if

call ScanWorks_Mem_Interconnect_Tests (Failed_In_SW_Testing, Mode$ & SW_MemInterconnectMsg$)
! if boardfailed then
!   call Disconnect_Power_On_Board
!   subexit
! end if

call ScanWorks_Cluster_Tests (Failed_In_SW_Testing, Mode$ & SW_ClusterMsg$)
! if boardfailed then
!   call Disconnect_Power_On_Board
!   subexit
! end if

call ScanWorks_Mem_BIST (Failed_In_SW_Testing, Mode$ & SW_MemBistMsg$)
if boardfailed then ! Abort if any individual IC tests fail
  call Disconnect_Power_On_Board
  subexit
end if

! If you are using Boundary-Scan and you want to cycle power,
! then uncomment the following call and the if-then-else statements.
! call Reset_Board
! if boardfailed then
!   call Disconnect_Power_On_Board
!   subexit
! end if

call Functional_Tests (Failed_In_Functional, Mode$ & DigitalFuncMsg$)
! if boardfailed then
!   call Disconnect_Power_On_Board
!   subexit
! end if

call Analog_Functional_Tests (Failed_In_Functional, Mode$ & AnalogPoweredMsg$)
if boardfailed then ! Abort if any functional tests fail
  call Disconnect_Power_On_Board
  subexit
end if

if Programming then
  if learning then subexit

  !----------------------------------------------------------------------------
  ! Only add the following powersupply setup if it is necessary to cycle power.
  ! Perhaps to get FPGAs or other ASICs to a three-state condition.
  !
  !    !flash! unpowered  ! Only if volatile logic exists upstream
  !
  !    !flash!  put any required gprelays here
  !
  !    !flash!  powered    ! if unpowered above, also use the following only if
  !                        ! digital devices aren't interferring
  !    ! call Setup_Power_Supplies (Failed_In_Power_Supplies, PowerMsg$)
  !    ! if boardfailed then
  !    !    call Disconnect_Power_On_Board
  !    !    subexit
  !    ! end if
  !----------------------------------------------------------------------------
  ! Add the device name to be tested in the call to the Program_Flash
  ! subroutine. If multiple devices are installed, duplicate the call line for
  ! each device.  Pass an empty string as the Message$ parameter to supress
  ! printing messages for devices 2 through N.
  !----------------------------------------------------------------------------

  ! call Program_Flash ("", Failed_In_Flash, FlashProgMsg$)
  if boardfailed then
    call Disconnect_Power_On_Board
    subexit
  end if

  call ScanWorks_Device_Programming (Failed_In_SW_Programming, SW_ProgrammingMsg$)
  if boardfailed then
    call Disconnect_Power_On_Board
    subexit
  end if

  call ScanWorks_Flash_Programming (Failed_In_SW_Flash, SW_FlashMsg$)
  if boardfailed then
    call Disconnect_Power_On_Board
    subexit
  end if
end if

! Uncomment the next line to turn off Fixture Power Supplies
! call Disconnect_FXT_Power_Supplies

Status = Passed
subend

!       Pin Test Subroutines

!##############################################################################
def fn Chek_Point_OK
! This is the subroutine for forcing the testing of pin contacts.
! If this routine is called before Test_sections (Chek_Point_Mode = Pretest),
! then the internal status will be set to Passed or Failed_Pin_Test.
! If this routine is called after test (Chek_Point_Mode = Failures), then the
! internal status is modified only if failures occur.
!
! The meaning of the function is slightly different when it is called before
! test versus after test.  If called before test, the function returns True
! if, no matter how many times it was cycled, pin test did finally pass.
! If called after test, the function returns True if pin test failed but
! passed after retry.
!
! Note: fn Pinsfailed is external to testmain.
!
global Pin_Msg$, Passed, Chek_Point_Msg$
global Retry_PinTest$, Recycle_Vacuum$, Status, True, False
global Cycle_Vacuum$, Failed_Pin_Test, Max_Times_To_Fix_Contact
global Logging, Serial$, Known_Good$, Chek_Point_Mode, Pretest, Failures

if learning then return (False)
Attempts = 0
loop
  Contact_Passed = not fn Pinsfailed (Chek_Point_Msg$)
  if not Contact_Passed then
    Status = Failed_Pin_Test
  else
    if Chek_Point_Mode = Pretest then Status = Passed
  end if
  Attempts = Attempts + 1
  exit if Contact_Passed or (Attempts > Max_Times_To_Fix_Contact)
  print Pin_Msg$
  question Retry_PinTest$, Retry
  exit if not Retry
  if Logging and Chek_Point_Mode = Pretest then
    if Status = Failed_Pin_Test then log board end Failed_Pin_Test
  end if
  question Cycle_Vacuum$, Cycle
  if Cycle then
    faoff
    question Recycle_Vacuum$
    faon 1.5
! Warning: Reducing the value for 'faon' from the default value of 1.5
! can potentially cause testhead damage.
    unpowered
  end if
  if Chek_Point_Mode = Pretest then
    clear failures
    if Logging then log board start Serial$, Known_Good$
  end if
end loop
if Chek_Point_Mode = Failures then
  if Contact_Passed and Attempts > 1 then
    if Logging then
      log clear for retest
      log board end Failed_Pin_Test
    end if
    clear failures
    report clear
  end if
  return (Contact_Passed and Attempts > 1)
else
  return (Contact_Passed)
end if
fnend

!       Reset_Board Subroutine

!##############################################################################
sub Reset_Board
   !---------------------------------------------------------------------------
   ! This 'pause' section is placed here to remind the test programmer
   ! that some powered tests may depend upon the TCK/TMS signals of
   ! boundary scan chains/devices being held in a stable state.
   ! When the testplan is run, the tests are properly sequenced
   ! to assure that the disabled state is set; however, board level
   ! circuitry may interfere with the persistence of the disabled state.
   ! You may need to take additional measures; for example, you may
   ! place your own pullup/down resistor in the fixture to assure a
   ! stable TMS and/or TCK, or utilize a GP relay to disable some TCK
   ! oscillator, etc.
   ! For further explanation, see the Boundary-Scan Manual for the
   ! section titled 'Maintaining Persistence of Boundary-Scan Disables'.
   !
   !---------------------------------------------------------------------------
   ! When Boundary-Scan tests are complete, you may need to produce
   ! a hard reset on the board-under-test to bring the ICs back into
   ! operational mode.  One way of doing this is to cycle power to the
   ! board using the following call:

   call Cycle_Power_On_Board ! Cycle Power to reset digital state of board
   ! call ScanWorks_Pretest    ! Configure volatile devices, if needed

   ! Power cycling is time consuming and may not be necessary.  Some boards
   ! may not need any resetting.  Others may have a digital reset node
   ! you can toggle with a digital test to reset the board.
   !
   ! When you have evaluated the needs of this board and modified this
   ! section, remove the pause and these comments.  You should take care
   ! to document the action you have taken for future reference.
   !---------------------------------------------------------------------------
subend

!       Data Logging Subroutines

!##############################################################################
sub Start_Logging
global Analog_Sample_Rate, QSTATS_Mode, Histo, Board$, Tests_On_This_Board
global Sampling, True, False
global Proc_Step$, Batch$, Oper$, Board_Rev$, Testplan$
global Testrev$, Known_Good$, Serial$, Version_Label$

Sampling = False
if learning then
  log level is all
else
  if rnd < Analog_Sample_Rate * (QSTATS_Mode = Histo) then
    log level is analog without nhls, pins
    Sampling = True
  else
!    log level is indictments without nhls
    log level is all
  end if
end if
print "Log level: ";lli$;";  Report level: ";rli$;";  Board type: ";Board$
PS$ = Proc_Step$
if Tests_On_This_Board = 1 then
  log board Board$, PS$, Batch$, Oper$, Board_Rev$, Testplan$, Testrev$, "", "", Version_Label$
end if
log board start Serial$, Known_Good$
print
subend

!##############################################################################
def fn Get_Serial_Num$(Prompt$)
global Bad_Serial_Image$, Default_Serial_Number$
global Serial_Length, Using_BtBasic

loop
  Ident$=""
  if Using_BtBasic then
    print using """"&Prompt$&""",#"
    input "",Ident$
  else
    input prompt Prompt$; Ident$
  end if
  if Ident$ = "" then Ident$ = Default_Serial_Number$
  exit if Ident$ = Default_Serial_Number$
  exit if (len(Ident$) = Serial_Length) or not Serial_Length
  print using Bad_Serial_Image$; len(Ident$), Serial_Length
end loop
return (Ident$)
! return (lwc$(Ident$))
fnend

!##############################################################################
!  If the Board name contains any invalid characters, stop processing.
sub Verify_Board_Names
global Stop_Msg$, Bad_Board_Name$, Board$

Found_Bad = 0
if fn IllegalChars_In_Board_Name(Board$) then
  Found_Bad = 1
  print Bad_Board_Name$  |   print "    ";Board$
end if
if Found_Bad then
  print | print Stop_Msg$
  beep
  stop
end if
subend

!##############################################################################
! Check to see if the Board name contains any invalid characters, now only
! check spaces.  Return 1 if yes, and 0 if no.
def fn IllegalChars_In_Board_Name (Board$)
global True, False

if len (Board$) > 0 and pos (Board$, " ") > 0  then
  return True
else
  return False
end if
fnend

!##############################################################################
sub Create_Log_Queue
global Log_Path$, Directory_Exists, Queue_Error_Msg$, Stop_Msg$
global TestEvents

create dir Log_Path$, Err
Err = Err and (Err <> Directory_Exists)
if Err then
  print Queue_Error_Msg$  |   print "    ";errm$
  print | print Stop_Msg$
  if TestEvents then rexit "TestEventsUCI"
  beep
  stop
end if
subend

!##############################################################################
sub Setup_Logging
global Serial$, Default_Serial_Number$, Testplan$, Batch$
global Known_Good_Board$, Using_ART, Proc_Step$, Oper_Id_Prompt$
global Board$, Oper$, Known_Good_Prompt$
global Serializing, Using_BtBasic

randomize
Proc_Step$             = "btest"
Batch$                 = datetime$ ! Set to a unique identifier so that Q-STATS II can
                                   ! calculate interboard handling and system idle times
Testplan$              = Board$
Default_Serial_Number$ = "default_SN" & th$
Serial$                = Default_Serial_Number$
Known_Good_Board$      = "O'Neill" ! Nah, I don't surf...
Oper$                  = ""
if Using_ART then
  if Using_BtBasic then
    print using """"&Oper_Id_Prompt$&""",#"
    input "",Oper$
  else
    input prompt Oper_Id_Prompt$; Oper$
  end if
end if
! if Serializing then Known_Good_Board$ = fn Get_Serial_Num$(Known_Good_Prompt$)
subend

!       Initialization Subroutines

!##############################################################################
sub Initializations
global Logging, Using_Buffered_Reporting, Report_Printer$, Using_ART
global Serializing, Logging_Started, First_Run$, Testmain_Revision$
global Did_First_Run_Inits, QSTATS_Mode
global True, False, Off, No_Histo, Histo, Pretest, Failures
global Version_Inits_Needed, Using_Multiple_Versions
global Per_Run, Per_Board, Version_Prompting
global Using_AwareTest, TestEvents
! IYET, WPR
global Using_IYET, Using_WPR
global Fpsfailed

Testmain_Revision$="i3070 08.20p WN(full)"
True = 1
False = 0
Off = 0
No_Histo = 1
Histo = 2
Pretest = 1
Failures = 2
Per_Run = 1
Per_Board = 2
Version_Inits_Needed = False
Fpsfailed = 0
call Set_Custom_Options
call Initialize_Board_Constants ! external to testmain
call Initialize_Constants
call Verify_Board_Names
Logging_Started = False
Logging = (QSTATS_Mode <> Off) or Using_ART
if Using_ART then Serializing = True
if Using_AwareTest then Serializing = True
if TestEvents then
   Serializing = True
   rinit "TestEventsUCI"; program "C:\Agilent_ICT\TestEventsUCI\TestEventsUCI.uci", servicetype "uci", timeout 86400
end if

! call Get_Board_Revision        ! to interactively set Board_Rev$

call Print_Startup_Message       ! prints out many variables' values
acknowledge all failures
learn capacitance off
if Using_Buffered_Reporting then
  buffered reporting on
else
  buffered reporting off
end if
report is Report_Printer$
printer is *
if Logging then
  call Setup_Logging
  call Create_Log_Queue
else
  log level is none
end if
if Using_ART then
  report level is all
else
  report level is report
end if
if nrun = 1 then
  print First_Run$
  load board

!'object checking on/off' statement goes here. Default is 'on'
  object checking on
end if
if Using_Multiple_Versions and Version_Prompting = Per_Run then
  call Get_Version_Label
end if
if nrun = 1 or Version_Inits_Needed then
  call Do_Version_Inits
  Did_First_Run_Inits=True
end if

! WPR
if Using_WPR then probe report on

! IYET
if Using_IYET then call IYET_Initialize

subend

!##############################################################################
sub Print_Startup_Message
global Board$, Board_Rev$, Using_ART, QSTATS_Mode, Histo
global Analog_Sample_Rate, Chek_Point_Mode, Failures
global Report_Printer$, Using_Buffered_Reporting, Testmain_Revision$
global Serializing, Serial_Length, TestEvents
! IYET
global Using_IYET, IYET_Report_On

print using "@,2/"
print "BOARD TYPE"
print "  Name:     ";Board$
print "  Revision: ";Board_Rev$
print "AGILENT ICT TESTMAIN"
print "  Report Printer: ";Report_Printer$
print "  Revision:       ";Testmain_Revision$
!   Build list of options to be printed
!     O1$ is first line, O2$ is second line
O1$ =  "  Options: "
if Using_ART then O1$=O1$&" PR+"
if TestEvents then O1$=O1$&" TestEvents"
if QSTATS_Mode then O1$=O1$&" QSTATS"
if Chek_Point_Mode then
  O1$=O1$&" Chek-Point"
  if Chek_Point_Mode = Failures then
    O1$=O1$&"-Failures"
  else
    O1$=O1$&"-Pretest"
  end if
end if
if (O1$="  Options: ") then
  O2$=O1$
else
  print O1$
  O2$= "           "
end if
if Serializing then O2$=O2$&" Serializing("&val$(Serial_Length)&")"
if learning then O2$=O2$&" LEARNING"
if Using_Buffered_Reporting then O2$=O2$&" Buffered-Reporting"
if QSTATS_Mode = Histo then
  O2$=O2$&" Histograms("&val$(Analog_Sample_Rate)&")"
end if
if not (O2$ = "           ") then print O2$
! IYET
O3$="           "
if Using_IYET then
  O3$=O3$&" Intelligent Yield Enhancement Test"
  if IYET_Report_On then O3$=O3$&"-Report"
end if
print O3$
print using "2/"
subend

!##############################################################################
sub Get_Board_Revision
global Board_Rev$, Board_Rev_Prompt$
global Using_BtBasic

if Board_Rev$ = "" then
  if Using_BtBasic then
    print using """" & Board_Rev_Prompt$ & """,#"
    input "",Board_Rev$
  else
    input prompt Board_Rev_Prompt$; Board_Rev$
  end if
end if
subend

!##############################################################################
sub Do_Version_Inits
global Version_Inits_Needed, Chek_Point_Mode, True, False, Off, Logging

unpowered
faoff
call Characterize
if Chek_Point_Mode <> Off then   ! preload pins into testhead memory
  Log_Level_Reset = False
  if lli$ = "all" then
    log level is none            ! turn off digital datalogging
    Log_Level_Reset = True       ! for 'ignore all failures'
  end if
  ignore all failures
  Err = fn Pinsfailed ("")       ! external to testmain
  acknowledge all failures
  if Log_Level_Reset = True then log level is all  ! reset datalogging
end if
Version_Inits_Needed = False
subend

!##############################################################################
sub Get_Version_Label
global Version_Label$, Version_Prompt$, True, False
global Version_Inits_Needed, Using_BtBasic

Old_Version$ = bvi$
Version_Inits_Needed = True
loop
  Version_Label$ = ""
  if Using_BtBasic then
    print using """" & Version_Prompt$ & """,#"
    input "", Version_Label$
  else
    input prompt Version_Prompt$; Version_Label$
  end if
  if Version_Label$ = "" or Version_Label$ = "*" then
    board version is *, Err
  else
    board version is Version_Label$, Err
  end if
  exit if not Err
  print errmlong$
end loop
if bvi$ = Old_Version$ then
  Version_Inits_Needed = False
end if
subend

!##############################################################################
def fn Replace_Character$(Char$)
  Val = num(Char$)
  if Val < 9 then
    String$ = "%00" & val$(Val)
  else
    if Val < 99 then
      String$ = "%0" & val$(Val)
    else
      String$ = "%" & val$(Val)
    end if
  end if
  return(String$)
fnend

def fn Replace_All_Chars$(String$, Char$)
To_Return$ = ""

String_Loop:

String_Loc = pos(String$, Char$)
if String_Loc = 0 then
  To_Return_New$ = To_Return$ & String$
else
  To_Return_New$ = To_Return$ & String$[1;String_Loc - 1] & fn Replace_Character$(Char$)
  String$ = String$[String_Loc + 1]
end if
To_Return$ = To_Return_New$
if String_Loc <> 0 then goto String_Loop
return(To_Return$)
fnend

def fn Remove_Special_Characters$(String$)
! used only with AwareTest.  Replaces all characters that cannot be
! used in an NT filename with their ASCII equivalent.

  To_Replace$ = fn Replace_All_Chars$(String$, "%")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, "|")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, "\")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, "/")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, "<")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, ">")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, "*")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, "?")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, ":")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, " ")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, """")
  return(To_Replace$)
fnend

!##############################################################################
sub Initialize_Constants
global PreshortsMsg$, ShortsMsg$, PowerMsg$, DigitalMsg$, AnalogMsg$
global DigitalFuncMsg$, AnalogPoweredMsg$, O$
global Break_Detected, Mode$, Board_Not_Tested$
global True, False, InvOn$, InvOff$, First_Run$, Board_Rev_Prompt$
global Pass_Msg$, Fail_Msg$, Pass_File$, Fail_File$, Stop_Msg$, Break_Msg$
global No_Init_Warning$, Rep_Test$, Place_Board_Prompt$, Learning_Off_Msg$
global BT_Passed$, BT_SR_Fail$, BT_CRC_Fail$, BT_Notest$, BT_Indeter$
global BT_Interm$, BT_Incons$, BT_Open$, BT_NResults$
global Confirming$, Confirm_Failed$
global Failed_In_Learn, Failed_Pin_Test, Failed_In_Preshorts, Failed_In_Shorts
global Failed_In_Analog, Failed_In_Power_Supplies, Failed_In_Digital
global Failed_In_Functional, Failed_In_BScan, Passed, Failed
global Directory_Exists, Log_Path$, System$, Queue_Error_Msg$, Board$
global Break_Code, Error_Code, Using_BtBasic
global But$, Serial_Prompt$, Bad_Serial_Image$, Oper_Id_Prompt$
global Known_Good_Prompt$, Serial_Nr$
global Retry_PinTest$, Cycle_Vacuum$, Recycle_Vacuum$
global Pin_Msg$, Max_Times_To_Fix_Contact
global BScanIntconMsg$, BScanIncktMsg$, Chek_Point_Msg$
global VectorlessTestMsg$, Failed_In_VectorlessTest
global PolarityMsg$, Failed_In_Polarity_Check
global BScanPShortsMsg$, No_Version_Init_Warning$
global Version_Label$, Version_Prompt$
global ConnectCheckMsg$, Failed_In_ConnectCheck
global Failed_In_Flash, FlashProgMsg$
global Serial_Number_Directory$, Not_AXI_Tested$, Serial_Suffix$
global AnalogClusterMsg$, Failed_In_Analog_Cluster
global PrePoweredMsg$, Failed_In_Pre_Powered
global BScanSiNailsMsg$, Failed_In_BScan_SiNails
global CoverExtendMsg$, Failed_In_Cover_Extend
global SW_ScanPathVerifyMsg$, Failed_In_SW_Testing
global SW_DrVerifyMsg$, SW_IrVerifyMsg$
global SW_InterconnectMsg$, SW_MemInterconnectMsg$
global SW_ClusterMsg$, SW_MemBistMsg$
global SW_ProgrammingMsg$, Failed_In_SW_Programming
global SW_FlashMsg$, Failed_In_SW_Flash
global VerifyGroundsMsg$, Failed_In_Verify_Grounds
global Bad_Board_Name$
global FixturePowerMsg$, Failed_In_FXT_Power_Supplies
global CET_FixturePowerMsg$, Failed_In_CET_FXT_Power_Supplies

Using_BtBasic = True
if localizable then Using_BtBasic = False

if Using_BtBasic then
  InvOn$                 = chr$(27)&"&dB"&chr$(7)  ! chr$(7) rings bell
  InvOff$                = chr$(27)&"&d@"
else
  InvOn$                 = "<FONT COLOR=blue SIZE=+2><B>"
  InvOff$                = "</B></FONT>"
end if

Break_Detected           = False
Passed                   = 0
Failed                   = 1
Failed_Pin_Test          = 2
Failed_In_Learn          = 3
Failed_In_Shorts         = 4
Failed_In_Analog         = 6
Failed_In_Power_Supplies = 7
Failed_In_Digital        = 8
Failed_In_Functional     = 9
Failed_In_Preshorts      = 10
! Status codes 11, 12 reserved for use by EFS
Failed_In_BScan          = 8      ! Equate to Failed_In_Digital
Failed_In_VectorlessTest = 14
Failed_In_Polarity_Check = 15
Failed_In_ConnectCheck   = 16
Failed_In_Analog_Cluster = 17
Failed_In_Flash          = 18
Failed_In_BScan_SiNails  = 19
Failed_In_SW_Testing     = 8      ! Equate to Failed_In_Digital
Failed_In_SW_Programming = 20
Failed_In_SW_Flash       = 21
Failed_In_Verify_Grounds = 22
Failed_In_Cover_Extend   = 23
Failed_In_Pre_Powered    = 24
Failed_In_FXT_Power_Supplies = 25
Failed_In_CET_FXT_Power_Supplies = 26
Error_Code               = 80
Break_Code               = 82
Directory_Exists         = 100312
Log_Path$                = btgetenv$("AGILENT3070_ROOT")&"/qm/logdata/testerq/"&Board$&"/"
enter "uname -n |";System$              ! gets hostname (without domain)
Max_Times_To_Fix_Contact = 4            ! MUST BE >= 1
Pin_Msg$                 = "FIXTURE CONTACT PROBLEM"
O$                       = InvOn$&"Press YES"&InvOff$
O$                       = O$&" to retry Pins Test, "&InvOn$&"NO"&InvOff$
Retry_PinTest$           = O$&" to test a new board."
O$                       = InvOn$&"Press YES"&InvOff$&" to cycle vacuum, "
Cycle_Vacuum$            = O$&InvOn$&"NO"&InvOff$&" Otherwise."
O$                       = InvOn$&"Press YES"&InvOff$
Recycle_Vacuum$          = O$&" to turn vacuum on and continue testing."
Queue_Error_Msg$         = "Cannot create directory to queue up log data.  Error is:"
But$                     = "Board Under Test: "
Serial_Prompt$           = InvOn$&"Enter"&InvOff$&" Board Serial #: "
O$                       = "/,""Identifier has wrong length ("",dd,""), must be "
Bad_Serial_Image$        = O$&""",dd,""."",/"
Oper_Id_Prompt$          = InvOn$&"Enter"&InvOff$&" Operator Identifier: "
Known_Good_Prompt$       = InvOn$&"Enter"&InvOff$&" Verification Board Identifier: "
Rep_Test$                = "Repeating test of this board!"
First_Run$               = "Please stand by -- doing first-run initializations"
No_Init_Warning$         = "** WARNING: FIRST RUN INITIALIZATIONS NOT COMPLETED --"
No_Init_Warning$         = No_Init_Warning$ & " CLEARING NRUN **"
O$                       = "** WARNING: VERSION CHANGE INITIALIZATIONS NOT"
No_Version_Init_Warning$ = O$ & " COMPLETED -- CLEARING NRUN **"
Pass_File$               = btgetenv$("AGILENT3070_ROOT")&"/util/pass"
Fail_File$               = btgetenv$("AGILENT3070_ROOT")&"/util/fail"
Board_Not_Tested$        = "Board not tested."
Pass_Msg$                = "P A S S E D"
Fail_Msg$                = "F A I L E D"
Stop_Msg$                = "P R O G R A M   S T O P P E D"
Break_Msg$               = "Break/Stop detected."
Place_Board_Prompt$      = "Place board on fixture and "&InvOn$&"press START"
Board_Rev_Prompt$        = InvOn$&"Enter"&InvOff$&" Board Revision: "
Confirming$              = "Confirming diagnosis..."
Confirm_Failed$          = "Confirm failed; restarting at node """
Learning_Off_Msg$        = "Learning turned off"
if learning then
  Mode$                  = "Learning "
else
  Mode$                  = "Testing "
end if
PreshortsMsg$            = "Preshorts"
ShortsMsg$               = "Shorts"
PowerMsg$                = "Setting Up Power Supplies"
DigitalMsg$              = "Digital Incircuit"
AnalogMsg$               = "Analog Unpowered"
AnalogClusterMsg$        = "Analog Cluster"
VectorlessTestMsg$       = "Vectorless Test"
PolarityMsg$             = "Polarity Check"
ConnectCheckMsg$         = "Connect Check"
DigitalFuncMsg$          = "Digital Functional"
AnalogPoweredMsg$        = "Analog Powered and Mixed"
BScanIntconMsg$          = "Boundary Scan Interconnect"
BScanIncktMsg$           = "Boundary Scan Incircuit"
BScanPShortsMsg$         = "Boundary Scan Powered Shorts"
BScanSiNailsMsg$         = "Boundary Scan Silicon Nails"
CoverExtendMsg$          = "Cover-Extend"
PrePoweredMsg$           = "Pre Powered Tests"
FlashProgMsg$            = "Programming Flash"
SW_ScanPathVerifyMsg$    = "Scan Path Verify with ScanWorks"
SW_DrVerifyMsg$          = "DR Verify with ScanWorks"
SW_IrVerifyMsg$          = "IR Verify with ScanWorks"
SW_InterconnectMsg$      = "Interconnect with ScanWorks"
SW_MemInterconnectMsg$   = "Memory Interconnect with ScanWorks"
SW_ClusterMsg$           = "Cluster with ScanWorks"
SW_MemBistMsg$           = "Memory BIST with ScanWorks"
SW_ProgrammingMsg$       = "Programming Devices with ScanWorks"
SW_FlashMsg$             = "Programming Flash with ScanWorks"
VerifyGroundsMsg$        = "Verify Grounds"
FixturePowerMsg$         = "Setting Up Fixture Power Supplies"
CET_FixturePowerMsg$     = "Setting Up Fixture Power Supplies for CET"
Serial_Nr$               = "Serial #: "
BT_Passed$               = "passed"
BT_SR_Fail$              = "failed vector "
BT_CRC_Fail$             = "failed CRC is """
BT_Notest$               = "was not tested"
BT_Indeter$              = "was indeterminate"
BT_Interm$               = "was intermittent"
BT_Incons$               = "was inconsistent"
BT_Open$                 = "has an open trace"
BT_NResults$             = "noderesults= "
Chek_Point_Msg$          = "Testing Pin Contact"
Version_Label$           = ""
Version_Prompt$          = InvOn$&"Enter"&InvOff$&" Version Label: "
Serial_Number_Directory$ = "AXI_passed_boards/"
Serial_Suffix$           = ".SNF"
Not_AXI_Tested$          = "Board did not pass AXI; cannot test on Agilent ICT."
SNF_Error_Msg$           = "Error accessing serial number file. Error is: "
Bad_Board_Name$          = "Board name contains space, cannot proceed:"
subend

!##############################################################################
sub Set_Custom_Options
!  All variables likely to need to be changed are initialized here.
!  The Usage flag(s) can be set True or False to selectively enable or
!  disable the code needed for each indicated subsystem or feature.
global Using_ART, QSTATS_Mode, Testrev$, TestEvents
global Analog_Sample_Rate
global Serializing, Serial_Length
global Chek_Point_Mode
global Report_Printer$, True, False, Using_Buffered_Reporting
global Off, Pretest, Failures, No_Histo, Histo
global Per_Run, Per_Board, Version_Prompting
global Programming, AXI_Tested_Override
! IYET, WPR
global Using_IYET, IYET_Shorts_Attempts, IYET_Analog_Tests_Attempts
global IYET_Report_On, IYET_VectorlessTest_Attempts, IYET_Preshorts_Attempts
global Using_WPR
global PMC_On ! Flag to enable/disable Power Monitoring Circuit (PMC)-For ASRU-N revision only

!   Usage flag(s)

QSTATS_Mode                  = No_Histo  ! Choose {Off, No_Histo, Histo}
Chek_Point_Mode              = Pretest   ! Choose {Off, Pretest, Failures}
Using_ART                    = False     ! Agilent Repair Tool.
TestEvents                   = True      ! Enable UCI 'TestEventsUCI' & sub 'TestEvents'.
Serializing                  = True      ! Will get set True if Using_ART or TestEvents.
Using_Buffered_Reporting     = True      ! Report failures during board handling
Programming                  = False     ! Execute Flash and device programming.
Using_IYET                   = True      ! Agilent Intelligent Yield Enhancement
                                         ! Test (IYET)
IYET_Report_On               = True      !   Create & display report on breaks
IYET_Preshorts_Attempts      = 3         !   Preshorts re-test attempts
IYET_Shorts_Attempts         = 3         !   Shorts re-test attempts
IYET_Analog_Tests_Attempts   = 3         !   Analog unp. re-test attempts
IYET_VectorlessTest_Attempts = 3         !   VectorlessTest re-test attempts
Using_WPR                    = True      ! Agilent Worse Probe Report (WPR)

!   Other parameters

!Report_Printer$          = btgetenv$("RPR"&th$) ! Final report destination
Report_Printer$           = "/dev/tty"  ! Send reports to the screen
Testrev$                  = "RevA"      ! Update this faithfully
Analog_Sample_Rate        = .10         ! Meaningful if QSTATS_Mode = Histo
Serial_Length             = 0           ! Board Id Length (0 = no checking)
Version_Prompting         = Per_Board   ! Choose {Per_Board, Per_Run}
                                        ! Used only on multiple version board
AXI_Tested_Override       = False       ! Choose {True, False}

PMC_On                    = False       ! Choose {True} to enable PMC, {False} to disable PMC
subend

!##############################################################################
sub Cleanup_Flash
global Logging, Report_level$

if Report_level$ = "all" then report level is all
if Report_level$ = "none" then report level is none
if Report_level$ = "log" then report level is log
if Report_level$ = "report" then report level is report
if Logging then
  call Set_Log_Level
end if
subend

!       Data Logging Subroutines

!##############################################################################
sub Set_Log_Level
global Sampling

if learning then
  log level is all
else
  if Sampling then
    log level is analog without nhls, pins
  else
!    log level is indictments without nhls
    log level is all
  end if
end if
subend

!       IYET Subroutines

!##############################################################################
sub IYET_Initialize

global IYET_Path$, IYET_Failure_File$, IYET_Retest_Log_File$
global O$, InvOn$, InvOff$
global IYET_Vacuum_Off_Delay, IYET_Vacuum_On_Delay
global IYET_Report_On, IYET_Max_Report_Count, IYET_File_Timeout
global IYET_Err_Msg$, IYET_NoRT_Msg$
global IYET_Test_Msg$, IYET_Max_Msg$, IYET_Fail_Msg$
global IYET_Rpt1_Msg$, IYET_Rpt2_Msg$, IYET_Rpt3_Msg$
global Chek_Point_Mode, Max_Times_To_Fix_Contact, Failures, True, False
global TestEvents

! Initialize paths and files
IYET_Path$                = "./iyet/"
IYET_Retest_Log_File$     = IYET_Path$&"retest"&datetime$[1;6]&".txt"
IYET_Failure_File$        = IYET_Path$&"failure.txt"

! Initialize variables
IYET_Vacuum_Off_Delay     = 1.5
IYET_Vacuum_On_Delay      = 1.5
IYET_Max_Report_Count     = 10
IYET_File_Timeout         = 5

! Initialize message strings
IYET_Err_Msg$  = "Error with file: "
IYET_NoRT_Msg$ = "No re-tests found or missing file: "
IYET_Test_Msg$ = "Re-testing "
IYET_Max_Msg$  = "Number of attempts for IYET must be > 0."
IYET_Fail_Msg$ = " failed, releasing board..."

! Initialize report strings
IYET_Rpt1_Msg$ = "IYET Unstable Test Report - from file: "
IYET_Rpt2_Msg$ = "Unstable Test"
IYET_Rpt3_Msg$ = "# Re-tests"

! When pins test is "Failures", disable redundant re-contacts
if Chek_Point_Mode = Failures then Max_Times_To_Fix_Contact = 1

! Create IYET directory
create dir IYET_Path$, Error
if (Error <> 100312) and (Error <> 0) then
   print IYET_Err_Msg$ & IYET_Path$
   print errmlong$(Error)
   if TestEvents then rexit "TestEventsUCI"
   beep
   stop
end if

! Generate and print re-test report
if (Error = 100312) and IYET_Report_On then
   print using "@"
   print IYET_Rpt1_Msg$ & IYET_Retest_Log_File$
   print
   call IYET_Create_Report
   print
   O$ = InvOn$&"Press YES"&InvOff$
   Prompt$ = O$&" to continue testing with IYET."
   question Prompt$, Continue
   if not Continue then
      if TestEvents then rexit "TestEventsUCI"
      stop
   end if
   print using "@"
end if
subend

!##############################################################################
sub IYET_Create_Report
! Collect all failing devices from log file and create retest report

global IYET_Retest_Log_File$
global IYET_Retest_Failing_Devices$(*), IYET_Top_Retests$(*)
global IYET_Max_Report_Count, IYET_File_Timeout
global IYET_NoRT_Msg$, IYET_Err_Msg$
global IYET_Rpt1_Msg$, IYET_Rpt2_Msg$, IYET_Rpt3_Msg$, TestEvents

! Open retest log file and get failing devices
assign @Retest_Log, Error to IYET_Retest_Log_File$;read
if Error then
   print IYET_NoRT_Msg$ & IYET_Retest_Log_File$
   print
   subexit
end if

! Read all failing devices until end of file or until IYET_File_Timeout.
Start_Time = msec
I = 0
loop
   Input$ = ""
   enter @Retest_Log,,Error;Input$
   if (Error <> 0) and (Error <> 101007) then
      print IYET_Err_Msg$ & IYET_Retest_Log_File$
      print errmlong$(Error)
      if TestEvents then rexit "TestEventsUCI"
      beep
      stop
   end if

   ! Look for shorts, vectorless test failures
   if pos(Input$," Report for """) then
      End_Input = pos(Input$,""".")
      Begin_Input = pos(Input$,"""") + 1
      Temp_device$ = Input$[Begin_Input;End_Input - Begin_Input]
      IYET_Retest_Failing_Devices$(I) = Temp_device$
      I = I + 1
   end if

   ! Look for analog failures
   if pos(Input$,"HAS FAILED") then
      IYET_Retest_Failing_Devices$(I) = Input$[1;pos(Input$,"HAS FAILED")-1]
      I = I + 1
   end if

   exit if Error = 101007

   if (msec - Start_Time)/1000 > IYET_File_Timeout then
      print IYET_Err_Msg$ & IYET_Retest_Log_File$
      if TestEvents then rexit "TestEventsUCI"
      beep
      stop
   end if
end loop

assign @Retest_Log to *
Device_Total = I-1

! Count failures and remove duplicates
K = 0
for I = 0 to Device_Total
   if IYET_Retest_Failing_Devices$(I) <> "" then
      Temp$ =  IYET_Retest_Failing_Devices$(I)
      Temp_Retests = 1
      for J = I + 1 to Device_Total
         if IYET_Retest_Failing_Devices$(J) <> "" then
            if Temp$ = IYET_Retest_Failing_Devices$(J) then
               Temp_Retests = Temp_Retests + 1
               IYET_Retest_Failing_Devices$(J) = ""
            end if
         end if
      next J
      IYET_Top_Retests$(K,1) = Temp$
      IYET_Top_Retests$(K,2) = val$(Temp_Retests)
      K = K + 1
   end if
next I
Top_Retest_Total = K-1

! Sort ascending
for I = 0 to Top_Retest_Total
   for J = Top_Retest_Total to 1 step -1
      if val(IYET_Top_Retests$(J,2)) > val(IYET_Top_Retests$(J-1,2)) then
         Temp$ = IYET_Top_Retests$(J-1,1)
         Temp_Retests = val(IYET_Top_Retests$(J-1,2))

         IYET_Top_Retests$(J-1,1) = IYET_Top_Retests$(J,1)
         IYET_Top_Retests$(J-1,2) = IYET_Top_Retests$(J,2)

         IYET_Top_Retests$(J,1) = Temp$
         IYET_Top_Retests$(J,2) = val$(Temp_Retests)
      end if
   next J
next I

! Print
IYET_Max_Report_Count = IYET_Max_Report_Count - 1
if Top_Retest_Total <= IYET_Max_Report_Count then
   IYET_Max_Report_Count = Top_Retest_Total
end if

print IYET_Rpt2_Msg$;tab (50);IYET_Rpt3_Msg$

for I = 0 to IYET_Max_Report_Count
   print IYET_Top_Retests$(I,1);tab (55);IYET_Top_Retests$(I,2)
next I
subend

!##############################################################################
sub IYET_Vacuum_Off
! Edit this subroutine to match your vacuum actuation commands. Note that the
! delay for vacuum off is completed in the "IYET_Vacuum_On" subroutine.

global IYET_Start_Vacuum_Off

IYET_Start_Vacuum_Off = msec
faoff 0
subend

!##############################################################################
sub IYET_Vacuum_On(Prompt$)
! Edit this subroutine to match your vacuum actuation commands. Do not
! comment the line:
!
!  question Prompt$,Continue | if not Continue then stop
!
! unless your fixture is approved for actuation without operator
! intervention.

global IYET_Start_Vacuum_Off, IYET_Vacuum_Off_Delay, IYET_Vacuum_On_Delay, TestEvents

question Prompt$,Continue
if not Continue then
   if TestEvents then
      call TestEvent("A") ! Aborted
      rexit "TestEventsUCI"
   end if
   stop
end if

! Wait for vacuum to release
loop
   exit if (msec - IYET_Start_Vacuum_Off)/1000 > IYET_Vacuum_Off_Delay
end loop

faon IYET_Vacuum_On_Delay
subend

!##############################################################################
sub IYET_Get_Failed_Tests (IYET_Abort)
! Collect all failing tests from failure file.
! To save time, this is called between the vacuum off and vacuum on.

global IYET_Failing_Tests$(*), IYET_Test_Total, IYET_File_Timeout
global IYET_Failure_File$, IYET_Retest_Log_File$, IYET_Err_Msg$
global Report_Printer$, Serial$, True, False, TestEvents
dim Failing_Tests$(0:2047)[40]

! Save failure ticket to retry log file
report is IYET_Retest_Log_File$,,Error;append
if Error then
   print IYET_Err_Msg$ & IYET_Retest_Log_File$
   print errmlong$(Error)
   if TestEvents then
      call TestEvent("A") ! Aborted
      rexit "TestEventsUCI"
   end if
   beep
   stop
end if
report "Board #:";bni
report "Version:";bvi$
report "S/N:"&Serial$| report out

! Save failure ticket to temporary file
report is IYET_Failure_File$,,Error
if Error then
   print IYET_Err_Msg$ & IYET_Failure_File$
   print errmlong$(Error)
   if TestEvents then
      call TestEvent("A") ! Aborted
      rexit "TestEventsUCI"
   end if
   beep
   stop
end if
report out

! Restore original report printer
report is Report_Printer$

! Open failure ticket and get failing tests
assign @Ticket, Error to IYET_Failure_File$;read
if Error then
   print IYET_Err_Msg$ & IYET_Failure_File$
   print errmlong$(Error)
   if TestEvents then
      call TestEvent("A") ! Aborted
      rexit "TestEventsUCI"
   end if
   beep
   stop
end if

! Read all failing tests until end of file or until IYET_File_Timeout.
Start_Time = msec
I = 0
IYET_Abort = False
loop
   Input$ = ""
   enter @Ticket,,Error;Input$
   if (Error <> 0) and (Error <> 101007) then
      print IYET_Err_Msg$ & IYET_Failure_File$
      print errmlong$(Error)
      if TestEvents then
         call TestEvent("A") ! Aborted
         rexit "TestEventsUCI"
      end if
      beep
      stop
   end if

   ! Look for shorts, vectorless test failures
   if pos(Input$," Report for """) then
      End_Input = pos(Input$,""".")
      Begin_Input = pos(Input$,"""") + 1
      Failing_Tests$(I) = Input$[Begin_Input;End_Input - Begin_Input]
      I = I + 1
   end if

   ! Look for analog test failures
   if pos(Input$,"HAS FAILED") then
      Failing_Tests$(I) = Input$[1;pos(Input$,"HAS FAILED")-1]
      I = I + 1
   end if

   ! Look for compensation failures and set abort flag
   if pos(Input$,"Compensation capacitance has not been") then
      IYET_Abort = True
   end if

   exit if IYET_Abort

   exit if Error = 101007

   if (msec - Start_Time)/1000 > IYET_File_Timeout then
      print IYET_Err_Msg$ & IYET_Failure_File$
      if TestEvents then
         call TestEvent("A") ! Aborted
         rexit "TestEventsUCI"
      end if
      beep
      stop
   end if
end loop

!remove duplicate tests
for K = 0 to I-1
   if Failing_Tests$(K) <> "" then
      Temp$ =  Failing_Tests$(K)
      for J = K + 1 to I-1
         if Failing_Tests$(J) <> "" then
            if Temp$ = Failing_Tests$(J) then
               Failing_Tests$(J) = ""
            end if
         end if
      next J
   end if
next K

I = 0
for J = 0 to K - 1
   if Failing_Tests$(J) <> "" then
      IYET_Failing_Tests$(I) = Failing_Tests$(J)
      I = I + 1
   end if
next J

assign @Ticket to *
IYET_Test_Total = I - 1

! Abort if no tests are found
if IYET_Test_Total < 0 then IYET_Abort = True

! Clear report buffer and failures unless aborted
if not IYET_Abort then
   report clear
   clear failures
end if
subend

!##############################################################################
sub IYET_Retest_Failed_Tests
global IYET_Failing_Tests$(*), IYET_Test_Total, IYET_Test_Msg$

for I = 0 to IYET_Test_Total
    print tab(11);IYET_Test_Msg$;lwc$(IYET_Failing_Tests$(I))
    test lwc$(IYET_Failing_Tests$(I))
next I
subend

!##############################################################################
sub IYET (TestType$, Maximum_Number_Attempts)
global Failed_In_Preshorts, PreshortsMsg$, Failed_In_Shorts, ShortsMsg$
global Failed_In_Analog, AnalogMsg$
global Failed_In_VectorlessTest, VectorlessTestMsg$
global Using_Buffered_Reporting, Logging, True, False, Mode$
global IYET_Fail_Msg$, Recycle_Vacuum$

Retests_Remaining = dround(Maximum_Number_Attempts,1) + 1

! Force log level, will be restored by Cleanup_Flash
if Logging then
!  log level is none ! Commented to log all data.
end if

! Force buffered reporting, save flag to restore at end
if not Using_Buffered_Reporting then
   buffered reporting on
   Not_Using_Buffered_Reporting = True
end if

! Call the test subroutine for the first time...
if TestType$ = PreshortsMsg$ then
   call Pre_Shorts (Failed_In_Preshorts, Mode$ & PreshortsMsg$)
end if

if TestType$ = ShortsMsg$ then
   call Shorts (Failed_In_Shorts, Mode$ & ShortsMsg$)
end if

if TestType$ = AnalogMsg$ then
   call Analog_Tests (Failed_In_Analog, Mode$ & AnalogMsg$)
end if

if TestType$ = VectorlessTestMsg$ then
   call VectorlessTest (Failed_In_VectorlessTest, Mode$ & VectorlessTestMsg$)
end if

Retests_Remaining = Retests_Remaining - 1

loop

   ! Exit if attempt is successful
   exit if (not boardfailed)

   ! Exit if done with re-tests
   exit if (Retests_Remaining = 0)

   ! Process failures during vacuum cycle time
   print tab(8);TestType$ & IYET_Fail_Msg$
   call IYET_Vacuum_Off
   call IYET_Get_Failed_Tests (IYET_Abort)
   call IYET_Vacuum_On(Recycle_Vacuum$)

   ! Exit if aborted
   exit if IYET_Abort

   ! For last time through the loop, restore logging and reporting
   if Retests_Remaining = 1 then call Cleanup_Flash

   ! Re-test
   call IYET_Retest_Failed_Tests
   Retests_Remaining = Retests_Remaining - 1

end loop

! Now some clean up. Could be redundant.

! Restore Log & Report level
call Cleanup_Flash

! Restore 'unbuffered' reporting, after dumping report buffer
if Not_Using_Buffered_Reporting then
   if boardfailed then report out
   buffered reporting off
end if
subend

!                          END OF TESTMAIN
!##############################################################################


sub TestEvent(EventCode$)
  global Board$, Serial$
  execute "C:/Program\ Files/TestEvents/TestEvent.bat " & Board$ & " " & Serial$ & " " & EventCode$; nowindow, nowait
  ! The "\ " in "C:/Program\ Files" above is necessary to escape the space in the path.
  ! The "nowindow, nowait" options cause this call to execute invisibly and to not wait for completion respectively.
  ! Board$ corresponds to TestEvent.java's variable & PostgreSQL's assembly_number fieldname.
  ! Serial$ corresponds to serial_number & serial_number respectively.
  ! EventCode$ corresponds to event_code & event_code respectively.
  ! This execute call will fail if Board$, Serial$ or EventCode contain spaces, because it's apparently
  ! not possible to embed or escape additional quotes in the execute command such that they'll
  ! work in TestEvent.bat.
subend

